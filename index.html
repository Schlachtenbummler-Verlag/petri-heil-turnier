<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Petri Heil â€“ Turnier</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#05090f" />
  <style>
    :root{
      --sound-enabled: 1;

      --bg-dark: #05090f;
      --bg-gradient-top: #071623;
      --bg-gradient-bottom: #02040a;

      --panel-bg: rgba(6, 14, 24, 0.96);
      --panel-border: rgba(148, 163, 184, 0.35);
      --panel-radius: 16px;

      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.22);
      --accent-2: #22c55e;
      --accent-danger: #fb7185;

      --text: #f9fafb;
      --text-muted: #9ca3af;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.75);

      --btn-bg: #111827;
      --btn-bg-soft: #020617;
      --btn-border: rgba(148, 163, 184, 0.45);
      --btn-hover: #1f2937;
      --btn-active-scale: 0.98;
      --btn-radius: 999px;
      --btn-font: 18px;

      --danger-bg: rgba(248, 113, 113, 0.14);
      --danger-border: rgba(248, 113, 113, 0.55);

      --table-header-bg: rgba(15, 23, 42, 0.96);
      --row-alt-bg: rgba(15, 23, 42, 0.75);
      --row-out-bg: rgba(15, 23, 42, 0.38);

      --leader-toast-bg: rgba(17, 24, 39, 0.97);
      --leader-toast-border: rgba(56, 189, 248, 0.6);

      --mini-water: rgba(56, 189, 248, 0.6);
      --mini-water-top: rgba(8, 47, 73, 0.95);

      --input-bg: rgba(15, 23, 42, 0.92);
      --input-border: rgba(148, 163, 184, 0.5);
      --input-radius: 10px;

      --max-width: 960px;
      --content-padding: 16px;
      --screen-gap: 16px;

      --transition-fast: 150ms ease-out;
      --transition-med: 220ms ease-out;
    }

    *{
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body{
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at top, var(--bg-gradient-top), transparent 55%),
        radial-gradient(circle at bottom, #020617, transparent 55%),
        linear-gradient(to bottom, var(--bg-gradient-top), var(--bg-gradient-bottom));
    }

    body{
      display: flex;
      align-items: stretch;
      justify-content: center;
     overflow: hidden; /* optional */
}

   main{
  flex: 1;
  display: flex;
  align-items: stretch;
  justify-content: center;
  width: 100%;
  max-width: none; /* keine feste Begrenzung mehr */
}


    .app-frame{
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 12px;
    }

    @media (min-width: 680px){
      .app-frame{
        padding: 22px;
      }
    }

    .screen{
      position: relative;
      flex: 1;
      display: none;
      flex-direction: column;
      padding: var(--content-padding);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.75), transparent 65%), var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: var(--panel-radius);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .screen-active{
      display: flex;
    }

    .screen-inner{
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--screen-gap);
      max-width: var(--max-width);
      margin: 0 auto;
      width: 100%;
    }

/* Hauptscreen: Unterwasser-Feeling */
#screen-main{
  position: relative;
  overflow: hidden;
  background:
    radial-gradient(circle at top, rgba(56, 189, 248, 0.35), transparent 55%),
    linear-gradient(to bottom, #0ea5e9 0%, #020617 80%);
}

/* Inhalt bleibt ein eigenes Layer */
#screen-main .screen-inner{
  position: relative;
  z-index: 1;
}

/* Blasen-Layer: nur oberer Bereich, damit Buttons unten frei bleiben */
.bubble-layer{
  position: absolute;
  left: 0;
  right: 0;
  top: 0vh;      /* weiter unten starten */
  bottom: 0;      /* fÃ¼llt den unteren Bereich */
  z-index: 0;     /* hinter MenÃ¼ / Buttons */
  overflow: hidden;
  pointer-events: auto;
}

/* einzelne Blase */
.bubble{
  --bubble-size: 18px;
  --bubble-left: 50%;
  --bubble-duration: 18s;
  --bubble-delay: 0s;
  --bubble-drift: 0px;
  --bubble-pop-base-transform: translate3d(0,0,0);

  position: absolute;
  bottom: -60px;
  left: var(--bubble-left);
  width: var(--bubble-size);
  height: var(--bubble-size);
  border-radius: 999px;

  background:
    radial-gradient(circle at 30% 30%,
      rgba(255,255,255,0.95),
      rgba(191,219,254,0.45) 40%,
      transparent 70%);
  box-shadow: 0 0 8px rgba(148, 163, 184, 0.7);

  opacity: 0;
  animation: bubble-rise var(--bubble-duration) linear infinite;
  animation-delay: var(--bubble-delay);

  pointer-events: auto;
  will-change: transform, opacity;
}

/* normale Aufstiegsanimation */
@keyframes bubble-rise{
  0%{
    transform: translate3d(0, 0, 0) scale(0.6);
    opacity: 0;
  }
  10%{
    opacity: 0.9;
  }
  80%{
    opacity: 0.95;
  }
  100%{
    transform: translate3d(var(--bubble-drift), -130vh, 0) scale(1.1);
    opacity: 0;
  }
}

/* Pop-Animation beim Anklicken */
.bubble-pop{
  animation: bubble-pop 260ms ease-out forwards;
}

@keyframes bubble-pop{
  0%{
    transform: var(--bubble-pop-base-transform) scale(1);
    opacity: 1;
  }
  70%{
    transform: var(--bubble-pop-base-transform) scale(1.35);
    opacity: 0.95;
  }
  100%{
    transform: var(--bubble-pop-base-transform) scale(0.2);
    opacity: 0;
  }
}


    .screen-inner.narrow{
      max-width: 640px;
    }

    h1, h2, h3{
      margin: 0;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    h1.title{
      font-size: clamp(26px, 5vw, 36px);
      text-align: center;
      text-transform: uppercase;
    }

    h1.title span{
      display: block;
      font-size: 0.64em;
      font-weight: 600;
      opacity: 0.9;
      letter-spacing: 0.25em;
    }

    .subtitle{
      margin-top: 6px;
      font-size: 16px;
      text-align: center;
      color: var(--text-muted);
    }

    .logo-fish{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 4px 10px;
      margin-bottom: 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(56, 189, 248, 0.45);
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--accent-soft);
    }

    .logo-fish span.icon{
      font-size: 18px;
    }

       .menu-buttons{
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 24px;
      align-items: center; /* Buttons nicht mehr Ã¼ber die ganze Breite strecken */
    }

    /* Nur Buttons im HauptmenÃ¼ schmaler machen */
    .menu-buttons .btn{
      width: auto;        /* Breite nach Inhalt */
      min-width: 220px;   /* damit sie nicht zu schmal werden */
      max-width: 280px;   /* optional: Obergrenze, damit sie nicht zu breit werden */
    }


    .btn{
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: var(--btn-radius);
      border: 1px solid var(--btn-border);
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.18), transparent 60%), var(--btn-bg);
      color: var(--text);
      font-size: var(--btn-font);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      transition: background var(--transition-med), transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast), opacity 120ms ease-out;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.65);
    }

    .btn.big{
      padding-block: 14px;
      font-size: 17px;
    }

    .btn.primary{
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.3), transparent 55%), linear-gradient(to right, #06b6d4, #22c55e);
      border-color: rgba(56, 189, 248, 0.85);
      box-shadow: 0 16px 30px rgba(8, 47, 73, 0.75);
    }

    .btn.secondary{
      background: radial-gradient(circle at top, rgba(129, 140, 248, 0.18), transparent 55%), linear-gradient(to right, #1f2937, #020617);
    }

    .btn.ghost{
      background: rgba(15, 23, 42, 0.85);
    }

    .btn.danger{
      border-color: var(--danger-border);
      background: radial-gradient(circle at top, rgba(248, 113, 113, 0.22), transparent 60%), var(--btn-bg-soft);
      color: #fecaca;
    }

    .btn:disabled{
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
    }

    .btn:active{
      transform: translateY(1px) scale(var(--btn-active-scale));
      box-shadow: 0 6px 10px rgba(0,0,0,0.75);
    }

    .btn span.kbd{
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      font-size: 11px;
      text-transform: none;
      letter-spacing: 0;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .top-bar{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 60%), rgba(15, 23, 42, 0.94);
      border: 1px solid rgba(148, 163, 184, 0.55);
    }

    .top-bar .title-small{
      display: flex;
      flex-direction: column;
      gap: 0;
      font-size: 13px;
    }

    .top-bar .title-small strong{
      font-size: 14px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    .round-info{
      font-size: 13px;
      color: var(--text-muted);
      text-align: right;
    }

    .badge-mode{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.5);
      background: rgba(15, 23, 42, 0.9);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent-soft);
    }

    .badge-mode span.dot{
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent-2);
      box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.28);
    }

    .badge-mode.elimination span.dot{
      background: #fb7185;
      box-shadow: 0 0 0 5px rgba(248, 113, 113, 0.35);
    }

    .block{
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.9));
      box-shadow: 0 14px 32px rgba(15, 23, 42, 0.9);
      padding: 12px 12px 10px;
    }

    .block-header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .block-title{
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .block-controls{
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .block-controls label{
      font-size: 13px;
    }

    select, input[type="number"], input[type="text"]{
      font-family: inherit;
      font-size: 14px;
      color: var(--text);
      background: var(--input-bg);
      border-radius: var(--input-radius);
      border: 1px solid var(--input-border);
      padding: 5px 8px;
      outline: none;
      min-width: 0;
    }

    select:focus,
    input:focus{
      border-color: rgba(56, 189, 248, 0.9);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.65);
    }

input.input-round.input-error{
  border-color: var(--danger-border);
  box-shadow: 0 0 0 1px var(--danger-border);
}


    .player-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin-top: 4px;
    }

    .player-table th,
    .player-table td{
      padding: 6px 6px;
      text-align: left;
    }

    .player-table th{
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      background: var(--table-header-bg);
      border-bottom: 1px solid rgba(55, 65, 81, 0.8);
      position: sticky;
      top: 0;
      z-index: 2;
    }

    .player-table tbody tr:nth-child(even){
      background: var(--row-alt-bg);
    }

    .player-row{
      border-bottom: 1px solid rgba(31, 41, 55, 0.85);
      transition: background 160ms ease-out, opacity 160ms ease-out, transform 140ms ease-out;
    }

    .player-row.row-hidden{
      display: none;
    }

    .player-row.is-out{
      background: var(--row-out-bg) !important;
      opacity: 0.6;
    }

    .player-row.is-out .player-status{
      color: #fecaca;
    }

    /* Spieler ohne Namen: ausgegraut, nehmen nicht teil */
    .player-row.is-inactive{
      opacity: 0.45;
    }

    .player-row.is-inactive .player-status{
      color: var(--text-muted);
    }


    .player-row input.player-name{
      width: 100%;
    }

    .player-row input.input-round{
      width: 100%;
      text-align: right;
    }

    .col-rank{
      width: 3.2rem;
    }

    .col-total{
      width: 4.5rem;
      text-align: right;
    }

    .col-round{
      width: 4.8rem;
    }
    .col-rank{
      width: 3.2rem;
    }

    .col-wins{
      width: 4.2rem;
      text-align: left;
    }

    .col-total{
      width: 4.5rem;
      text-align: right;
    }

    .col-round{
      width: 4.8rem;
    }

       .player-wins{
      min-height: 18px;
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      align-items: center;
    }

    .player-win-star{
      font-size: 10px;
      line-height: 1;
      color: #facc15; /* gold-gelb */
      text-shadow: 0 0 4px rgba(250, 204, 21, 0.85);
    }


    .player-rank{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 26px;
      min-height: 26px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.65);
      font-size: 13px;
    }

    .player-total{
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }

    .player-status{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

/* --- Avatare & Namensspalte (neuer Stil) --- */

.col-avatar{
  width: 4.8rem;
}

.player-avatar{
  position: relative;
  width: 56px;
  height: 56px;
  border-radius: 999px;
  border: 3px solid rgba(148, 163, 184, 0.85); /* Farbe wird im JS pro Spieler gesetzt */
  padding: 0;
  margin: 0 auto;
  background: radial-gradient(circle at top, rgba(248, 250, 252, 0.95), rgba(15, 23, 42, 0.98));
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 8px 18px rgba(15, 23, 42, 0.96);
  transition:
    transform 120ms ease-out,
    box-shadow 120ms ease-out,
    border-color 150ms ease-out,
    opacity 120ms ease-out;
}

.player-avatar:hover:not(:disabled){
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(15, 23, 42, 0.98);
}

.player-avatar:active:not(:disabled){
  transform: translateY(1px) scale(0.98);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.98);
}

.player-avatar:disabled{
  cursor: default;
  opacity: 0.7;
  box-shadow: 0 4px 8px rgba(15, 23, 42, 0.9);
}

.player-avatar-inner{
  width: 48px;
  height: 48px;
  border-radius: 999px;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
}

.player-avatar-inner.has-image{
  color: transparent; /* Emoji ausblenden, wenn Foto vorhanden */
}

/* Namensspalte etwas schmaler */
.player-row input.player-name{
  width: 100%;
  max-width: 150px;
}


    .block-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .hint{
      font-size: 16px;
      color: var(--text-muted);
    }

    .hint strong{
      color: var(--accent-soft);
      font-weight: 500;
    }

    .exit-btn{
  position: absolute;
  left: 10px;
  bottom: 10px;

  /* NEU: gleiche GrÃ¶ÃŸe & Typo wie Standard-Buttons */
  padding: 10px 18px;               /* wie .btn */
  font-size: var(--btn-font);       /* wie .btn */
  text-transform: uppercase;        /* wie .btn */
  letter-spacing: 0.12em;           /* wie .btn */

  box-shadow: 0 10px 22px rgba(0, 0, 0, 0.78);
}


    .highscore-panel{
      margin-top: auto;
      margin-bottom: 10px;
      text-align: center;
      font-size: 18px;
      color: var(--text-muted);
    }

    .highscore-title{
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent-soft);
      margin-bottom: 4px;
    }

    .highscore-line{
      font-size: 14px;
      line-height: 1.4;
    }


    @media (min-width: 720px){
      .exit-btn{
        left: 20px;
        bottom: 18px;
      }
    }

    .modal-backdrop{
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(3, 7, 18, 0.98));
      backdrop-filter: blur(16px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 40;
    }

    .modal{
      max-width: 420px;
      width: 100%;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98));
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.98);
      padding: 18px 18px 14px;
    }

    .modal h3{
      font-size: 18px;
      margin-bottom: 6px;
    }

    .modal p{
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--text-muted);
    }

    .modal-actions{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 6px;
    }

    .hidden{
      display: none !important;
    }

      .leader-toast{
      position: absolute;
      bottom: 22px; /* unten statt oben */
      left: 50%;
      transform: translateX(-50%) translateY(20px); /* von unten ins Bild gleiten */
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--leader-toast-border);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.28), transparent 55%), var(--leader-toast-bg);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.95);
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      opacity: 0;
      pointer-events: none;
      z-index: 30;
      transition: opacity 180ms ease-out, transform 180ms ease-out;
    }

    .leader-toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }


    .leader-toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .leader-toast span.name{
      font-weight: 700;
      color: var(--accent-soft);
    }

    .toggle{
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      padding: 3px;
      width: 74px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.75);
      cursor: pointer;
      transition: border-color var(--transition-med), background var(--transition-med);
    }

    .toggle-knob{
      position: relative;
      width: 32px;
      height: 26px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #22c55e, #16a34a);
      box-shadow: 0 10px 16px rgba(22, 163, 74, 0.68);
      transform: translateX(0);
      transition: transform var(--transition-med), box-shadow var(--transition-med), background var(--transition-med);
    }

    .toggle.off .toggle-knob{
      transform: translateX(34px);
      background: radial-gradient(circle at top, #9ca3af, #4b5563);
      box-shadow: 0 10px 16px rgba(15, 23, 42, 0.9);
    }

    .toggle-labels{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-inline: 9px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      pointer-events: none;
    }

    .toggle.off .label-on{
      opacity: 0.25;
    }
    .toggle:not(.off) .label-off{
      opacity: 0.25;
    }

    .option-row{
      padding: 10px 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: radial-gradient(circle at left, rgba(56, 189, 248, 0.16), transparent 55%), rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .option-main{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .option-label{
      font-size: 16px;
      font-weight: 500;
    }

    .option-hint{
      font-size: 16px;
      color: var(--text-muted);
    }

    .options-actions{
      display: flex;
      justify-content: flex-end;
      margin-top: 10px;
    }

    .rounds-input-row{
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    .rounds-input-row input{
      width: 90px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .rounds-actions{
      display: flex;
      justify-content: space-between;
      margin-top: 14px;
      gap: 8px;
    }

    .winner-headline{
      margin-top: 10px;
      font-size: 17px;
      font-weight: 600;
    }

  .ranking-list{
  margin: 14px 0 0;
  padding-left: 0;
  list-style: none;
}

/* jedes Ergebnis-Item */
.ranking-item{
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 6px;
}

/* Gewinner optisch hervorheben */
.ranking-item.winner,
.ranking-list li.winner{
  color: var(--accent-soft);
  font-weight: 600;
}

/* Pokal links (SVG-Icon) â€“ schwarze SVG wird per Filter eingefÃ¤rbt */
.rank-trophy{
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

/* Grundstil fÃ¼rs Bild â€“ wird von den Varianten Ã¼berschrieben */
.rank-trophy img{
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 4px rgba(0,0,0,0.7));
  transition: filter 0.25s ease;
}

/* GOLD â€“ schwarzes SVG â†’ warmes Gold */
.trophy-gold img{
  filter:
    invert(78%)          /* Schwarz â†’ hell */
    sepia(96%)
    saturate(950%)
    hue-rotate(5deg)
    brightness(1.05)
    contrast(1.05)
    drop-shadow(0 0 8px rgba(250, 204, 21, 0.9));
}

/* SILBER â€“ leicht blÃ¤ulich, hell */
.trophy-silver img{
  filter:
    invert(90%)
    sepia(5%)
    saturate(200%)
    hue-rotate(180deg)
    brightness(1.3)
    contrast(0.9)
    drop-shadow(0 0 8px rgba(209, 213, 219, 0.9));
}

/* BRONZE â€“ warmes Kupfer */
.trophy-bronze img{
  filter:
    invert(18%)
    sepia(96%)
    saturate(6500%)
    hue-rotate(0deg)
    brightness(1.05)
    contrast(1.1);
}

/* Farben + Glow fÃ¼r Top-3 (falls Text/Fallback benutzt wird) */
.rank-trophy.trophy-gold{
  color: #facc15;
  text-shadow: 0 0 6px rgba(250, 204, 21, 0.8);
}

.rank-trophy.trophy-silver{
  color: #e5e7eb;
  text-shadow: 0 0 6px rgba(209, 213, 219, 0.8);
}

.rank-trophy.trophy-bronze{
  color: #f97316; /* schÃ¶nes Orange */
  text-shadow: 0 0 8px rgba(249, 115, 22, 0.9);
}


/* Avatar-Spalte im Ranking â€“ immer gleich breit */
.rank-avatar{
  width: 56px;   /* feste Spaltenbreite fÃ¼r alle Zeilen */
  height: 56px;
  border-radius: 999px;
  border: 2px solid rgba(148, 163, 184, 0.75);
  background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
  box-shadow: 0 8px 16px rgba(15, 23, 42, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

/* eigentlicher Avatar-Kreis im Inneren */
.rank-avatar-inner{
  width: 44px;
  height: 44px;
  border-radius: inherit;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
}

/* Gewinner-Avatar nur innen grÃ¶ÃŸer, Spaltenbreite bleibt gleich */
.ranking-item.winner .rank-avatar{
  box-shadow: 0 0 18px rgba(56, 189, 248, 0.65);
}

.ranking-item.winner .rank-avatar-inner{
  width: 50px;
  height: 50px;
  font-size: 26px;
}

/* Text rechts vom Avatar */
.rank-text{
  flex: 1;
  min-width: 0;
  text-align: left;   /* explizit linksbÃ¼ndig */
}

.rank-text-main{
  font-size: 15px;
  font-weight: 600;
}

.rank-text-sub{
  font-size: 12px;
  color: var(--text-muted);
}


    .winner-actions{
      display: flex;
      justify-content: space-between;
      margin-top: 18px;
      gap: 8px;
    }

    .help-text{
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .help-list{
      margin-top: 8px;
      padding-left: 18px;
      font-size: 14px;
      color: var(--text-muted);
    }

    .mini-bg{
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at top, rgba(56, 189, 248, 0.16), transparent 60%),
        linear-gradient(to top, #020617, #082f49);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .mini-overlay{
      position: relative;
      z-index: 2;
      max-width: 520px;
      width: 100%;
      padding: 18px 18px 16px;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.75);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
      box-shadow: 0 24px 40px rgba(15, 23, 42, 0.98);
      text-align: center;
    }

    .mini-title{
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 6px;
    }

    .mini-sub{
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--text-muted);
    }

    .mini-player-name{
      color: #bae6fd;
    }

  .mini-water{
  position: absolute;
  inset: auto 0 0 0;
  height: 0;
  background: linear-gradient(to top, var(--mini-water), var(--mini-water-top));
  box-shadow: 0 -18px 40px rgba(8, 47, 73, 0.9);
  transform-origin: bottom;
}

.mini-water.animate{
  animation: water-rise 2600ms ease-in forwards;
}

@keyframes water-rise{
  0%{ height: 0; }
  50%{ height: 40%; }
  100%{ height: 75%; }
}


    /* NEU: Icon des Spielers, der ins Wasser fÃ¤llt */
        .mini-player{
      position: absolute;
      top: 18%;
      left: 50%;
      transform: translateX(-50%) translateY(0);
      width: 148px;
      height: 148px;
      border-radius: 999px;
      border: 2px solid rgba(148, 163, 184, 0.9);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.98);
      z-index: 1;
      opacity: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mini-player.show{
      opacity: 1;
    }

    .mini-player.fall{
      animation: mini-player-fall 1200ms cubic-bezier(.22,.7,.2,1.05) forwards;
    }

    .mini-player-img{
      width: 140px;
      height: 140px;
      border-radius: 999px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 38px;
    }

/* Icon dreht sich, wÃ¤hrend der Spieler fÃ¤llt */
.mini-player.fall .mini-player-img{
  animation: mini-player-spin 1200ms linear forwards;
}

@keyframes mini-player-spin{
  0%{
    transform: rotate(0deg);
  }
  100%{
    transform: rotate(420deg); /* etwas mehr als eine Umdrehung */
  }
}


   @keyframes mini-player-fall{
  0%{
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
  60%{
    transform: translateX(-50%) translateY(160px);
  }
  100%{
    transform: translateX(-50%) translateY(260px);
    opacity: 0;
  }
}

 

    .title-row{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
    }

    .footer-note{
      margin-top: auto;
      font-size: 14px;
      text-align: center;
      color: rgba(148, 163, 184, 0.75);
      padding-top: 6px;
    }

    .footer-note span.mark{
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <main>
    <div class="app-frame">

      <!-- Screen 1: HauptmenÃ¼ -->
          <section id="screen-main" class="screen screen-active">
  <!-- Blasen-Hintergrund nur im HauptmenÃ¼ -->
  <div class="bubble-layer" id="bubble-layer"></div>

  <div class="screen-inner narrow">
    <div class="title-row">
      <h1 class="title">Petri Heil<span>Scoreboard</span></h1>
      <p class="subtitle">Verwaltet eure Punkte Ã¼ber mehrere Spiele â€“ mit optionaler Spieler-Eliminierung.</p>
    </div>

    <div class="menu-buttons">
      <button id="btn-main-start" class="btn primary big">Start</button>
      <button id="btn-main-options" class="btn secondary big">Optionen</button>
      <button id="btn-main-help" class="btn ghost big">Anleitung</button>
      <button id="btn-main-quit" class="btn danger ghost big">Beenden</button>
    </div>

    <div class="highscore-panel">
      <div class="highscore-title">HÃ¶chstpunktestand</div>
      <div class="highscore-line" id="hs-best-round">
        â€“ Punkte in einem Spiel: â€“
      </div>
      <div class="highscore-line" id="hs-best-game">
        â€“ Punkte in einem Turnier Ã¼ber â€“ Spiele: â€“
      </div>
    </div>

    <div class="footer-note">
      <span class="mark">Schlachtenbummler-Verlag Crimmitschau</span> â€“ Ronny Dannler 2025
    </div>
  </div>
</section>



      <!-- Screen 2: Optionen -->
      <section id="screen-options" class="screen">
        <div class="screen-inner narrow">
          <div class="top-bar">
            <div class="title-small">
              <strong>Optionen</strong>
             </div>
            <div class="badge-mode elimination" id="badge-mode-preview">
              <span class="dot"></span>
              <span class="label">Eliminierung</span>
            </div>
          </div>

                    <div class="block">
            <div class="option-row">
              <div class="option-main">
                <div class="option-label">Eliminierungsmodus</div>
                <button id="toggle-elimination" class="toggle">
                  <div class="toggle-knob"></div>
                  <div class="toggle-labels">
                    <span class="label-on">AN</span>
                    <span class="label-off">AUS</span>
                  </div>
                </button>
              </div>
              <p class="option-hint">Wenn aktiv, scheidet nach jedem Spiel der Spieler mit den wenigsten Endpunkten aus. Bei Gleichstand gibt es keine Eliminierung.</p>
            </div>

            <!-- NEU: Siegbedingung (nur ohne Eliminierung sinnvoll) -->
            <div class="option-row" id="option-win-row" style="margin-top: 10px;">
              <div class="option-main">
                <div class="option-label">Siegbedingung</div>
                <button id="btn-win-condition" class="btn ghost" type="button">
                  Gesamtpunkte
                </button>
              </div>
              <p class="option-hint" id="option-win-hint">
                Gilt nur ohne Eliminierung: Entweder gewinnt die hÃ¶chste Gesamtpunktzahl oder die meisten gewonnenen Spiele (â˜…).
              </p>
            </div>

            <div class="option-row" style="margin-top: 10px;">
              <div class="option-main">
                <div class="option-label">Sound</div>
                <button id="toggle-sound" class="toggle">
                  <div class="toggle-knob"></div>
                  <div class="toggle-labels">
                    <span class="label-on">AN</span>
                    <span class="label-off">AUS</span>
                  </div>
                </button>
              </div>
              <p class="option-hint">Einzelne Sounds spielen bei Spielwertung, Eliminierung und Sieg ab.</p>
            </div>
          </div>


          <div class="options-actions">
            <button id="btn-options-back" class="btn secondary">ZurÃ¼ck</button>
          </div>

          <div class="footer-note">
            Ã„nderungen gelten fÃ¼r das nÃ¤chste gestartete Turnier.
          </div>
        </div>
      </section>

      <!-- Zwischenbildschirm: Spielrundenanzahl bei deaktivierter Eliminierung -->
      <section id="screen-rounds" class="screen">
        <div class="screen-inner narrow">
          <div class="top-bar">
            <div class="title-small">
              <strong>Spielrundenanzahl</strong>
              <span>Eliminierung deaktiviert</span>
            </div>
            <div class="badge-mode">
              <span class="dot"></span>
              <span class="label">feste Spielrunden</span>
            </div>
          </div>

          <h2 style="margin-top: 10px;">Wie viele Spiele wollt ihr spielen?</h2>
          <p class="help-text">
            Spielereliminierung ist deaktiviert. Stattdessen endet das Turnier automatisch nach einer festen Anzahl von Spielen.
          </p>

          <div class="rounds-input-row">
            <label for="round-count">Spiele:</label>
            <input id="round-count" type="number" min="1" max="99" value="5" />
          </div>
          <p class="hint">Tipp: <strong>5â€“10 Spiele</strong> funktionieren fÃ¼r die meisten Turniere â€žPetri Heilâ€œ sehr gut.</p>

          <div class="rounds-actions">
            <button id="btn-rounds-back" class="btn secondary">ZurÃ¼ck</button>
            <button id="btn-rounds-next" class="btn primary">Weiter</button>
          </div>

          <div class="footer-note">
            Du kannst die Spielrundenanzahl spÃ¤ter jederzeit Ã¼ber ein neues Turnier Ã¤ndern.
          </div>
        </div>
      </section>

      <!-- Screen 3: Spieler & Punkte -->
      <section id="screen-game" class="screen">
        <div class="screen-inner">
          <div class="top-bar">
            <div class="title-small">
              <strong>Petri Heil â€“ Turnier</strong>
              <span>Punkte, Spiele & RÃ¤nge</span>
            </div>
            <div>
              <div id="badge-mode-current" class="badge-mode elimination">
                <span class="dot"></span><span class="label"></span>
              </div>
              <div class="round-info" id="round-info"></div>
            </div>
          </div>

          <div class="block">
            <div class="block-header">
              <div class="block-title">Spieler & Punkte</div>
              <div class="block-controls">
                <label for="player-count">Anzahl Spieler:</label>
                <select id="player-count">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4" selected>4</option>
                  <option value="5">5</option>
                  <option value="6">6</option>
                </select>
              </div>
            </div>

            <div class="table-wrapper">
              <table class="player-table">
              <thead>
  <tr>
    <th class="col-rank">Rang</th>
    <th class="col-avatar">Profilbild</th>
    <th>Name</th>
    <th class="col-wins">Siege</th>
    <th class="col-total">Gesamt</th>
    <th class="col-round">+ Punkte</th>
    <th>Status</th>
  </tr>
</thead>


                <tbody id="player-tbody">
                  <!-- 6 Slots -->
                 <tr class="player-row" data-id="0">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 1" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                  <tr class="player-row" data-id="1">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 2" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                  <tr class="player-row" data-id="2">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 3" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                 <tr class="player-row" data-id="3">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 4" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                 <tr class="player-row" data-id="4">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 5" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                  <tr class="player-row" data-id="5">
  <td class="col-rank"><span class="player-rank">â€“</span></td>

  <!-- NEU: Avatar-Spalte -->
  <td class="col-avatar">
    <button type="button" class="player-avatar">
      <div class="player-avatar-inner">ðŸŽ£</div>
    </button>
    <input
      type="file"
      accept="image/*"
      capture="environment"
      class="player-avatar-input"
      hidden
    />
  </td>

  <td><input type="text" class="player-name" placeholder="Spieler 6" maxlength="15" /></td>
   <td class="col-wins"><div class="player-wins"></div></td>
<td class="col-total"><span class="player-total">0</span></td>
  <td class="col-round"><input type="number" class="input-round" inputmode="numeric" min="1" step="1" /></td>
  <td><span class="player-status"></span></td>
</tr>

                </tbody>
              </table>
            </div>

            <div class="block-actions">
              <button id="btn-round-clear" class="btn ghost">Punkte lÃ¶schen</button>
              <button id="btn-round-apply" class="btn primary">Spiel werten</button>
            </div>

            <p class="hint">Nach jedem <strong>Spiel</strong> werden die RÃ¤nge automatisch neu berechnet. Im Eliminierungsmodus scheidet der Spieler mit den wenigsten Punkten aus.</p>
          </div>
       

                   <!-- Highscore wird nur im HauptmenÃ¼ angezeigt -->

          <button id="btn-exit-game" class="btn danger exit-btn">Beenden</button>


        <!-- Leader Toast -->
        <div id="leader-toast" class="leader-toast hidden">
          <span class="name" id="leader-name"></span>&nbsp;fÃ¼hrt!
        </div>

        <!-- Exit-Modal -->
        <div id="exit-modal-backdrop" class="modal-backdrop hidden">
          <div class="modal">
            <h3>Wirklich beenden?</h3>
            <p>Wenn du <strong>Ja</strong> drÃ¼ckst, gelangst du ins HauptmenÃ¼ zurÃ¼ck und alle Punkte gehen verloren.</p>
            <div class="modal-actions">
              <button id="btn-exit-cancel" class="btn secondary">Nein, weiterspielen</button>
              <button id="btn-exit-confirm" class="btn danger">Ja, ins HauptmenÃ¼</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Screen 4: Gewinneranzeige -->
      <section id="screen-winner" class="screen">
        <div class="screen-inner narrow">
          <div class="top-bar">
            <div class="title-small">
              <strong>Turnierende</strong>
              <span>Petri Heil â€“ Wertung</span>
            </div>
          </div>

          
         <p class="winner-headline" id="winner-headline">â€“</p>


          <ol id="winner-ranking" class="ranking-list"></ol>

                  <div class="winner-actions">
            <button id="btn-winner-again" class="btn primary">Neues Turnier</button>
            <button id="btn-winner-menu" class="btn secondary">HauptmenÃ¼</button>
          </div>

          <div class="footer-note" id="footer-tip">
            ðŸŽ£ Tipp: Nach dem Turnier gibtâ€™s hier einen zufÃ¤lligen Angeltipp.
          </div>

        </div>
      </section>

      <!-- Minispiel / Screensaver fÃ¼r Eliminierung -->
      <section id="screen-mini" class="screen">
  <div class="mini-bg">
    <div class="mini-water" id="mini-water"></div>

    <!-- NEU: Icon des Spielers, der gleich ins Wasser fÃ¤llt -->
    <div class="mini-player" id="mini-player">
  <div class="mini-player-img" id="mini-player-img">ðŸŽ£</div>
</div>


    <div class="mini-overlay">
      <div class="mini-title" id="mini-title">Petri Heil â€“ Eliminierung</div>
      <p class="mini-sub">
        <span class="mini-player-name" id="mini-player-name">Spieler X</span> ist ausgeschieden.
      </p>
      <p class="mini-sub">Das Wasser steigt â€“ gleich geht's weiter mit der nÃ¤chsten Runde.</p>
      <button id="btn-mini-continue" class="btn primary big">Weiter</button>
    </div>
  </div>
</section>


      <!-- Anleitung -->
      <section id="screen-help" class="screen">
        <div class="screen-inner narrow">
          <div class="top-bar">
            <div class="title-small">
              <strong>Anleitung</strong>
              </div>
          </div>

          <h2 style="margin-top: 10px;">So funktioniert die Turnier-App</h2>
          <p class="help-text">
            Diese App verwaltet eure Punkte fÃ¼r â€žPetri Heilâ€œ Ã¼ber mehrere Spiele.
            Ihr kÃ¶nnt mit bis zu <strong>6 Spielern</strong> spielen und wahlweise einen
            <strong>Eliminierungsmodus</strong> oder eine feste Anzahl an Spielrunden verwenden.
          </p>
          <ul class="help-list">
            <li>In den <strong>Optionen</strong> festlegen, ob ihr mit Spieler-Eliminierung spielt.</li>
            <li>WÃ¤hlt eine <strong>Siegbedingung</strong>.</li>
            <li>Im HauptmenÃ¼ auf <strong>Start</strong> klicken.</li>
            <li>Ohne Eliminierung wÃ¤hlt ihr nach dem Start eine feste <strong>Anzahl an Spielen</strong>.</li>
            <li>Tragt im Wertungsbildschirm mindestens<strong> 2 Namen</strong> ein.</li>
            <li>Klickt neben euren Namen auf das runde <strong>Profilbild</strong> um es zu Ã¤ndern.</li>
            <li>Gebt nach jedem Spiel Petri Heil eure jeweiligen Endpunkte ein.</li>
            <li>Mit drÃ¼cken auf <strong>Spielwertung</strong> werden die RÃ¤nge nach jedem Spiel neu sortiert und angezeigt, wer gerade im Turnier fÃ¼hrt.</li>
            <li>Im Eliminierungsmodus scheidet der Spieler mit den wenigsten Punkten aus.</li>
            <li>Das Turnier endet, wenn nur noch ein Spieler Ã¼brig ist oder die Anzahl an eingestellten Spielen erreicht wurde.</li>
          </ul>

          <div class="winner-actions">
            <button id="btn-help-back" class="btn secondary">ZurÃ¼ck</button>
          </div>

          <div class="footer-note">
            Hinweis: Diese App verwaltet nur Punkte â€“ alle â€žPetri Heilâ€œ-Regeln bleiben natÃ¼rlich bestehen.
          </div>
        </div>
      </section>

             <audio id="snd-click"   src="assets/snd/click.mp3?v=1"   preload="auto"></audio>
      <audio id="snd-points"  src="assets/snd/points.mp3?v=1"  preload="auto"></audio>
      <audio id="snd-splash"  src="assets/snd/splash.mp3?v=1"  preload="auto"></audio>
      <audio id="snd-fanfare" src="assets/snd/fanfare.mp3?v=1" preload="auto"></audio>
      <audio id="snd-fail"    src="assets/snd/fail.mp3?v=1"    preload="auto"></audio>

      <!-- Loop: Unterwasser-Atmo im HauptmenÃ¼ -->
      <audio id="snd-underwater" src="assets/snd/underwater.mp3?v=1" preload="auto" loop></audio>

      <!-- Blub-Sounds fÃ¼r platzende Blasen -->
      <audio id="snd-bub1" src="assets/snd/bub1.mp3?v=1" preload="auto"></audio>
      <audio id="snd-bub2" src="assets/snd/bub2.mp3?v=1" preload="auto"></audio>
      <audio id="snd-bub3" src="assets/snd/bub3.mp3?v=1" preload="auto"></audio>
      <audio id="snd-bub4" src="assets/snd/bub4.mp3?v=1" preload="auto"></audio>


    </div>
  </main>

     <script>
    (function(){
      "use strict";

            const MAX_PLAYERS = 6;

      // NEU: Vollbild + Querformat
      let fullscreenRequested = false;

      function tryEnterFullscreen(){
        if(fullscreenRequested) return;
        fullscreenRequested = true;

        const el = document.documentElement; // komplette Seite

        try{
          if(el.requestFullscreen){
            el.requestFullscreen().catch(function(){});
          }else if(el.webkitRequestFullscreen){
            el.webkitRequestFullscreen();
          }else if(el.msRequestFullscreen){
            el.msRequestFullscreen();
          }
        }catch(e){
          // ignorieren, wenn der Browser zickt
        }

        // Querformat-Sperre versuchen (klappt nur in manchen Browsern)
        if(screen.orientation && screen.orientation.lock){
          screen.orientation.lock("landscape").catch(function(){});
        }
      }

      function setupFullscreenOnFirstInteraction(){
        const handler = function(){
          tryEnterFullscreen();
          window.removeEventListener("pointerdown", handler);
          window.removeEventListener("keydown", handler);
        };

        // erster Tap/Klick/Tastendruck â†’ Vollbild
        window.addEventListener("pointerdown", handler);
        window.addEventListener("keydown", handler);
      }


      // ZufÃ¤llige Angeltipps fÃ¼r den Winner-Screen
            const fishingTips = [
        // 1
        "FrÃ¼h morgens und in der AbenddÃ¤mmerung sind viele Fische besonders aktiv â€“ plane deine AusflÃ¼ge um diese Zeiten herum.",
        // 2
        "Leise bewegen: Vibrationen am Ufer kÃ¶nnen Fische verschrecken. Geh ruhig und vermeide laute GerÃ¤usche.",
        // 3
        "Passe die HakengrÃ¶ÃŸe an den KÃ¶der und die Fischart an â€“ ein zu groÃŸer Haken wirkt oft unnatÃ¼rlich.",
        // 4
        "Knoten sind entscheidend: Ãœbe ein bis zwei zuverlÃ¤ssige Angelknoten und kontrolliere sie vor jedem Wurf.",
        // 5
        "Beobachte das Wasser: StrÃ¶mungskanten, UnterstÃ¤nde und Krautfelder sind hÃ¤ufige Hotspots fÃ¼r Fische.",
        // 6
        "Wechsle den KÃ¶der, wenn lÃ¤ngere Zeit nichts beiÃŸt â€“ manchmal macht eine andere Farbe oder Form den Unterschied.",
        // 7
        "Halte deine Schnur stets leicht auf Spannung, um Bisse frÃ¼hzeitig zu spÃ¼ren und besser anschlagen zu kÃ¶nnen.",
        // 8
        "Wind aus gleicher Richtung Ã¼ber lÃ¤ngere Zeit kann Futter und damit auch Fische an eine Uferseite treiben.",
        // 9
        "Ein aufgerÃ¤umtes Tackle erleichtert dir das Angeln: Halte KÃ¶der, Zangen und Haken immer griffbereit.",
        // 10
        "Nutze mÃ¶glichst scharfe Haken â€“ stumpfe Haken kosten dich Bisse und damit vielleicht deinen Traumfisch.",
        // 11
        "Geduld ist eine der wichtigsten Angel-FÃ¤higkeiten: Bleib konzentriert, auch wenn lÃ¤nger nichts passiert.",
        // 12
        "Wechsle hin und wieder die Tiefe, in der du angelst â€“ Fische stehen je nach Wetter und Tageszeit unterschiedlich hoch.",
        // 13
        "Notiere dir Fangdatum, Wetter, KÃ¶der und Platz in einem einfachen Angeltagebuch, um Muster zu erkennen.",
        // 14
        "Schnur regelmÃ¤ÃŸig prÃ¼fen: Kleine BeschÃ¤digungen oder Knicke kÃ¶nnen bei einem starken Fisch zum Schnurbruch fÃ¼hren.",
        // 15
        "Passe die Bremskraft deiner Rolle an â€“ zu stramm riskiert Schnurbruch, zu locker verlierst du leicht Spannung.",
        // 16
        "Achte auf deine Silhouette: Wenn du direkt am Ufer stehst und dich abzeichnest, kÃ¶nnen Fische dich wahrnehmen.",
        // 17
        "Schonendes Release: Befeuchte deine HÃ¤nde vor dem Anfassen des Fisches, um seine Schleimschicht zu schÃ¼tzen.",
        // 18
        "Bei klarerem Wasser sind unauffÃ¤llige VorfÃ¤cher oft erfolgreicher als dicke, auffÃ¤llige SchnÃ¼re.",
        // 19
        "Nach einem Fehlbiss nicht sofort aufgeben â€“ wirf den KÃ¶der noch ein bis zwei Mal an die gleiche Stelle.",
        // 20
        "Sicherheit nicht vergessen: Trage bei Bootsangeln immer eine Schwimmweste und achte auf Haken in deiner NÃ¤he.",
        // 21
        "Bei plÃ¶tzlichen Wetterwechseln â€“ etwa kurz vor einem Regen â€“ kÃ¶nnen Fische besonders aktiv werden. Ein kurzer Angelausflug lohnt sich dann oft.",
        // 22
        "Bei trÃ¼bem Wasser funktionieren auffÃ¤llige, helle oder kontrastreiche KÃ¶der meist besser als natÃ¼rliche Farben.",
        // 23
        "In sehr klarem Wasser fangen unauffÃ¤llige, natÃ¼rliche KÃ¶derfarben und dÃ¼nnere VorfÃ¤cher oft deutlich mehr Fische.",
        // 24
        "An heiÃŸen Sommertagen stehen viele Fische lieber im Schatten, in tieferen Bereichen oder unter Ã¼berhÃ¤ngenden BÃ¤umen.",
        // 25
        "Im Winter lohnt es sich, langsamer zu angeln und KÃ¶der lÃ¤nger an einer Stelle anzubieten â€“ Fische sind trÃ¤ger.",
        // 26
        "Polarisationsbrille tragen: Du siehst Hindernisse unter Wasser besser und erkennst Bisse oder NachlÃ¤ufer schneller.",
        // 27
        "Bleie, Posen und KÃ¶der immer wieder kontrollieren â€“ ein verheddertes Vorfach fÃ¤ngt selten gut.",
        // 28
        "Lieber einen zuverlÃ¤ssigen Angelknoten gut beherrschen als viele Knoten halbherzig kÃ¶nnen.",
        // 29
        "Passe deine KÃ¶dergrÃ¶ÃŸe der Fischart an: Kleine Haken und KÃ¶der bringen oft mehr Bisse als Ã¼berdimensionierte Montagen.",
        // 30
        "Ein sauber ausgebleites Posenrig, bei dem nur noch die Spitze sichtbar ist, zeigt selbst zaghafte Bisse an.",
        // 31
        "Benutze eine KÃ¶dersorte, die am GewÃ¤sser hÃ¤ufig als Futter vorkommt â€“ Fische vertrauen Bekanntem eher.",
        // 32
        "Beim Spinnfischen lohnt es sich, Einholgeschwindigkeit und Pausen stÃ¤ndig zu variieren, bis du ein Muster findest.",
        // 33
        "Bei Raubfischen wie Hecht ein geeignetes Vorfachmaterial verwenden, damit sie die Schnur nicht durchbeiÃŸen.",
        // 34
        "Teste verschiedene Tiefen: Oft stehen Fische nur einen halben Meter hÃ¶her oder tiefer, als du zunÃ¤chst vermutest.",
        // 35
        "Wirf deinen KÃ¶der fÃ¤cherfÃ¶rmig in unterschiedliche Richtungen aus, um eine Stelle systematisch abzusuchen.",
        // 36
        "Bei starkem Angeldruck kÃ¶nnen unauffÃ¤llige Montagen und kleine KÃ¶der oft den Unterschied machen.",
        // 37
        "Ein kleiner Futterplatz, den du regelmÃ¤ÃŸig mit wenig Futter bedienst, ist oft effektiver als einmalige Futterorgien.",
        // 38
        "Markiere dir gute Angelstellen in einer Karte oder App, um spÃ¤ter gezielt dorthin zurÃ¼ckzukehren.",
        // 39
        "Halte beim Ansitzen immer eine zweite, einfache Montage bereit, falls du schnell auf eine Situation reagieren musst.",
        // 40
        "Lass den KÃ¶der nach dem Auswerfen kurz ruhen, bevor du ihn bewegst â€“ viele Bisse kommen in den ersten Sekunden.",
        // 41
        "Kontrolliere nach jedem gehakten Fisch deinen Haken: Ist er verbogen oder stumpf, sofort wechseln.",
        // 42
        "Eine zu harte, zu fest eingestellte Bremse fÃ¼hrt schnell zu Schnurbruch â€“ lieber etwas weicher einstellen.",
        // 43
        "Im Drill immer gleichmÃ¤ÃŸig Druck machen und nicht ruckartig an der Schnur ziehen.",
        // 44
        "Plane beim Landen genug Zeit ein: Ein zu frÃ¼h gedrillter Fisch kann direkt vor dem Kescher ausschlitzen.",
        // 45
        "Lege Kescher und Abhakmatte griffbereit zurecht, bevor du den ersten Wurf machst.",
        // 46
        "Fische nie direkt am Haken festhalten â€“ eine kleine Zange oder ein HakenlÃ¶ser schÃ¼tzt dich und den Fisch.",
        // 47
        "Nasse deine HÃ¤nde vor dem Anfassen des Fisches, um seine Schleimschicht mÃ¶glichst wenig zu beschÃ¤digen.",
        // 48
        "Halte dich an Schonzeiten und MindestmaÃŸe â€“ sie sichern den Fischbestand deines GewÃ¤ssers.",
        // 49
        "Dokumentiere besondere FÃ¤nge mit LÃ¤nge, Gewicht und KÃ¶der in einem Fangtagebuch, um Muster zu erkennen.",
        // 50
        "Wenn du lÃ¤nger keinen Biss bekommst, Ã¤ndere nur einen Faktor auf einmal: KÃ¶der, Tiefe oder Platz â€“ so lernst du, was wirkt.",
        // 51
        "Beobachte WasseroberflÃ¤che und Ufer: springende Fische, blasende WeiÃŸfische oder jagende RÃ¤uber verraten gute Spots.",
        // 52
        "In FlÃ¼ssen sind Kanten, RÃ¼ckstrÃ¶mungen und Kehrwasser oft echte Hotspots fÃ¼r neugierige Fische.",
        // 53
        "Bei Wind lohnt es sich hÃ¤ufig, mit dem Wind ins Gesicht zu angeln â€“ Treibgut und Futter werden an dieses Ufer gedrÃ¼ckt.",
        // 54
        "Lass KÃ¶der und Futter nicht in der Sonne liegen; viele NaturkÃ¶der halten sich im Schatten deutlich lÃ¤nger frisch.",
        // 55
        "Halte deine AusrÃ¼stung mÃ¶glichst leicht und Ã¼bersichtlich â€“ stÃ¤ndiges Suchen kostet Angelzeit.",
        // 56
        "Eine kleine Stirnlampe gehÃ¶rt bei DÃ¤mmerungs- und Nachtansitzen fast immer zur Grundausstattung.",
        // 57
        "Pack immer eine Zange, Pflaster und ggf. einen Seitenschneider ein â€“ Sicherheit geht vor.",
        // 58
        "MÃ¼ll und alte Schnurreste nimmst du immer mit â€“ ein sauberes Ufer schadet dem Angeln nie.",
        // 59
        "Neue GewÃ¤sser lernst du schneller kennen, wenn du mit lokalen Anglern sprichst und ihre Hinweise ernst nimmst.",
        // 60
        "Als Einsteiger lohnt es sich, mit einer einfachen Posen- oder Grundmontage zu starten, bevor du komplizierte Methoden probierst.",
        // 61
        "Konzentriere dich lieber auf wenige Zielfischarten und Techniken, statt alles gleichzeitig ausprobieren zu wollen.",
        // 62
        "Wenn du Raubfisch und Friedfisch kombinierst, lege Friedfischruten etwas abseits â€“ Unruhe am Platz kann Raubfische verschrecken.",
        // 63
        "Bei starkem Kraut im Wasser sind leicht auftreibende oder flach laufende KÃ¶der oft im Vorteil.",
        // 64
        "Nach starken RegenfÃ¤llen kÃ¶nnen EinlÃ¤ufe und leicht eingetrÃ¼bte Bereiche besonders fÃ¤ngig sein.",
        // 65
        "Bei Nachtangeln helfen leuchtende Posen oder Knicklichter, Bisse rechtzeitig zu erkennen.",
        // 66
        "Zieh KÃ¶der bei KÃ¤lte langsamer und mit lÃ¤ngeren Pausen â€“ Fische sind dann weniger bereit, weite Strecken zu jagen.",
        // 67
        "Eine passend gewÃ¤hlte RutenlÃ¤nge erleichtert dir die KÃ¶derfÃ¼hrung und das Landen deutlich â€“ nicht jede Rute passt zu jedem GewÃ¤sser.",
        // 68
        "Achte bei der Schnurwahl auf das Zusammenspiel mit Rolle und Rute â€“ zu dicke Schnur bremst Wurfweite und KÃ¶deraktion.",
        // 69
        "Wenn du Ã¶fter Fehlbisse hast, verkleinere den Haken oder den KÃ¶der, statt immer nur grÃ¶ÃŸer zu werden."
      ];


      function getRandomFishingTip(){
        if(!fishingTips.length) return "Angeln heiÃŸt warten, beobachten und den Moment genieÃŸen.";
        const idx = Math.floor(Math.random() * fishingTips.length);
        return fishingTips[idx];
      }


      // Standard-Avatare (werden zufÃ¤llig & ohne Wiederholung auf die Slots verteilt)
      const defaultAvatarImages = [
        "assets/img/p1.jpg",
        "assets/img/p2.jpg",
        "assets/img/p3.jpg",
        "assets/img/p4.jpg",
        "assets/img/p5.jpg",
        "assets/img/p6.jpg"
      ];

      // Rahmenfarben pro Spieler-Slot
      const avatarBorderColors = [
        "#38bdf8", // blau
        "#f97316", // orange
        "#a855f7", // violett
        "#22c55e", // grÃ¼n
        "#eab308", // gelb
        "#fb7185"  // rot/pink
      ];

      function shuffleArray(arr){
        for(let i = arr.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
      }

                 // Name in "Titel-Case" bringen und max. 15 Zeichen,
      // ABER: wenn nichts eingegeben wurde, wirklich leer lassen
      function formatPlayerName(raw, fallback){
        let s = (raw || "").trim();

        // kein Name eingegeben â†’ Spieler nimmt nicht teil
        if(!s){
          return "";
        }

        s = s.toLowerCase();
        const parts = s.split(/(\s+|-)/); // Trenner (Leerzeichen / Bindestrich) behalten
        for(let i = 0; i < parts.length; i++){
          // nur "Wortteile" groÃŸ schreiben
          if(parts[i].trim() === "" || parts[i] === "-") continue;
          parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);
        }

        let result = parts.join("");
        if(result.length > 15){
          result = result.slice(0, 15);
        }
        return result;
      }



    
           const state = {
        options: {
          elimination: true,
          sound: true,
          winCondition: "points" // "points" oder "wins"
        },

        playerCount: 4,
        totalRounds: null,
        currentRound: 0,
        players: [],
        currentLeaderId: null,
        gameFinished: false,
        pendingWinnerAfterMini: false,
        highscores: {
          bestRoundPoints: 0,
          bestRoundName: "",
          bestGamePoints: 0,
          bestGameName: "",
          bestGameRounds: 0
        }
      };

      // === LocalStorage: Optionen & Highscores ===
      const STORAGE_KEY_OPTIONS    = "petriHeilTournamentOptions";
      const STORAGE_KEY_HIGHSCORES = "petriHeilTournamentHighscores";

            function saveOptionsToStorage(){
        try{
          const data = {
            elimination: !!state.options.elimination,
            sound: !!state.options.sound,
            winCondition: (state.options.winCondition === "wins" ? "wins" : "points")
          };
          localStorage.setItem(STORAGE_KEY_OPTIONS, JSON.stringify(data));
        }catch(e){
          // Ignorieren, z.B. wenn localStorage nicht verfÃ¼gbar ist
        }
      }

      function saveHighscoresToStorage(){
        try{
          const data = {
            bestRoundPoints: state.highscores.bestRoundPoints,
            bestRoundName:   state.highscores.bestRoundName,
            bestGamePoints:  state.highscores.bestGamePoints,
            bestGameName:    state.highscores.bestGameName,
            bestGameRounds:  state.highscores.bestGameRounds
          };
          localStorage.setItem(STORAGE_KEY_HIGHSCORES, JSON.stringify(data));
        }catch(e){
          // Ignorieren
        }
      }

      function loadFromStorage(){
        try{
          // Optionen
          const optRaw = localStorage.getItem(STORAGE_KEY_OPTIONS);
          if(optRaw){
            const opt = JSON.parse(optRaw);
            if(typeof opt.elimination === "boolean"){
              state.options.elimination = opt.elimination;
            }
            if(typeof opt.sound === "boolean"){
              state.options.sound = opt.sound;
            }
            if(typeof opt.winCondition === "string"){
              if(opt.winCondition === "wins" || opt.winCondition === "points"){
                state.options.winCondition = opt.winCondition;
              }
            }
          }

          // Highscores
          const hsRaw = localStorage.getItem(STORAGE_KEY_HIGHSCORES);
          if(hsRaw){
            const hs = JSON.parse(hsRaw);
            if(typeof hs.bestRoundPoints === "number"){
              state.highscores.bestRoundPoints = hs.bestRoundPoints;
            }
            if(typeof hs.bestRoundName === "string"){
              state.highscores.bestRoundName = hs.bestRoundName;
            }
            if(typeof hs.bestGamePoints === "number"){
              state.highscores.bestGamePoints = hs.bestGamePoints;
            }
            if(typeof hs.bestGameName === "string"){
              state.highscores.bestGameName = hs.bestGameName;
            }
            if(typeof hs.bestGameRounds === "number"){
              state.highscores.bestGameRounds = hs.bestGameRounds;
            }
          }
        }catch(e){
          // Wenn Parsing schief geht o.Ã„., ignorieren wir das einfach.
        }
      }

      const screens = {
        main:   document.getElementById("screen-main"),
        options:document.getElementById("screen-options"),
        rounds: document.getElementById("screen-rounds"),
        game:   document.getElementById("screen-game"),
        winner: document.getElementById("screen-winner"),
        mini:   document.getElementById("screen-mini"),
        help:   document.getElementById("screen-help")
      };

      let currentScreen = "main";


      const btnMainStart   = document.getElementById("btn-main-start");
      const btnMainOptions = document.getElementById("btn-main-options");
      const btnMainHelp    = document.getElementById("btn-main-help");
      const btnMainQuit    = document.getElementById("btn-main-quit");

      const toggleElimination  = document.getElementById("toggle-elimination");
      const toggleSound        = document.getElementById("toggle-sound");
      const btnOptionsBack     = document.getElementById("btn-options-back");
      const badgeModePreview   = document.getElementById("badge-mode-preview");
      const btnWinCondition    = document.getElementById("btn-win-condition");
      const optionWinHint      = document.getElementById("option-win-hint");


      const roundCountInput = document.getElementById("round-count");
      const btnRoundsBack   = document.getElementById("btn-rounds-back");
      const btnRoundsNext   = document.getElementById("btn-rounds-next");

      const playerCountSelect = document.getElementById("player-count");
      const playerTbody       = document.getElementById("player-tbody");
      const playerRows        = Array.from(playerTbody.querySelectorAll(".player-row"));

      const playerAvatarButtons = [];
      const playerAvatarInputs  = [];
      playerRows.forEach(function(row){
        const btn   = row.querySelector(".player-avatar");
        const input = row.querySelector(".player-avatar-input");
        playerAvatarButtons.push(btn);
        playerAvatarInputs.push(input);
      });

      // Rahmenfarben pro Avatar setzen
      playerAvatarButtons.forEach(function(btn, idx){
        if(btn){
          btn.style.borderColor = avatarBorderColors[idx % avatarBorderColors.length];
        }
      });

      const btnRoundApply = document.getElementById("btn-round-apply");
      const btnRoundClear = document.getElementById("btn-round-clear");
      const btnExitGame   = document.getElementById("btn-exit-game");
      const roundInfo     = document.getElementById("round-info");
      const badgeModeCurrent = document.getElementById("badge-mode-current");
      const hsBestRound   = document.getElementById("hs-best-round");
      const hsBestGame    = document.getElementById("hs-best-game");


      const leaderToast   = document.getElementById("leader-toast");
      const leaderNameEl  = document.getElementById("leader-name");

      const exitModalBackdrop = document.getElementById("exit-modal-backdrop");
      const btnExitCancel     = document.getElementById("btn-exit-cancel");
      const btnExitConfirm    = document.getElementById("btn-exit-confirm");

      const winnerHeadline = document.getElementById("winner-headline");
      const winnerRanking  = document.getElementById("winner-ranking");
      const btnWinnerAgain = document.getElementById("btn-winner-again");
      const btnWinnerMenu  = document.getElementById("btn-winner-menu");
      const footerTipEl   = document.getElementById("footer-tip");

      const miniTitle      = document.getElementById("mini-title");
      const miniPlayerName = document.getElementById("mini-player-name");
      const miniWater      = document.getElementById("mini-water");
      const miniPlayer     = document.getElementById("mini-player");
      const miniPlayerImg  = document.getElementById("mini-player-img");
      const btnMiniContinue= document.getElementById("btn-mini-continue");

      const btnHelpBack = document.getElementById("btn-help-back");

           const sndClick   = document.getElementById("snd-click");
      const sndPoints  = document.getElementById("snd-points");
      const sndSplash  = document.getElementById("snd-splash");
      const sndFanfare = document.getElementById("snd-fanfare");
      const sndFail    = document.getElementById("snd-fail");

      const sndUnderwater = document.getElementById("snd-underwater");
      const sndBub = [
        document.getElementById("snd-bub1"),
        document.getElementById("snd-bub2"),
        document.getElementById("snd-bub3"),
        document.getElementById("snd-bub4")
      ];

      function playSound(audioEl){
        if(!state.options.sound) return;
        if(!audioEl) return;
        try{
          audioEl.currentTime = 0;
          audioEl.play().catch(function(){});
        }catch(e){}
      }

      function playBubblePopSound(){
        if(!state.options.sound) return;

        const available = sndBub.filter(function(a){ return !!a; });
        if(!available.length) return;

        const audioEl = available[Math.floor(Math.random() * available.length)];
        try{
          audioEl.currentTime = 0;
          audioEl.play().catch(function(){});
        }catch(e){}
      }


      function setRootSoundFlag(){
        document.documentElement.style.setProperty("--sound-enabled", state.options.sound ? "1" : "0");
      }

      function updateUnderwaterLoop(){
        if(!sndUnderwater) return;

        try{
          if(currentScreen === "main" && state.options.sound){
            sndUnderwater.loop = true;
            if(sndUnderwater.paused){
              sndUnderwater.currentTime = 0;
              sndUnderwater.play().catch(function(){});
            }
          }else{
            sndUnderwater.pause();
          }
        }catch(e){}
      }


      function updateToggleVisual(toggleEl, on){
        if(on){
          toggleEl.classList.remove("off");
        }else{
          toggleEl.classList.add("off");
        }
      }

      function updateModeBadges(){
        const labelMain    = badgeModeCurrent.querySelector(".label");
        const labelPreview = badgeModePreview.querySelector(".label");
        if(state.options.elimination){
          badgeModeCurrent.classList.add("elimination");
          badgeModePreview.classList.add("elimination");
          if(labelMain)    labelMain.textContent = "Eliminierung";
          if(labelPreview) labelPreview.textContent = "Eliminierung";
        }else{
          badgeModeCurrent.classList.remove("elimination");
          badgeModePreview.classList.remove("elimination");
          if(labelMain)    labelMain.textContent = "feste Runden";
          if(labelPreview) labelPreview.textContent = "feste Runden";
        }
      }
      function updateWinConditionUI(){
        if(!btnWinCondition) return;

        if(state.options.elimination){
          // Im Eliminierungsmodus ist die Siegbedingung nicht einstellbar
          btnWinCondition.disabled = true;
          btnWinCondition.textContent = "Gesamtpunkte";
          if(optionWinHint){
            optionWinHint.textContent =
              "Im Eliminierungsmodus gewinnt immer der letzte verbleibende Spieler â€“ die Siegbedingung ist hier nicht einstellbar.";
          }
        }else{
          btnWinCondition.disabled = false;
          if(state.options.winCondition === "wins"){
            btnWinCondition.textContent = "Gewonnene Spiele (â˜…)";
          }else{
            btnWinCondition.textContent = "Gesamtpunkte";
          }
          if(optionWinHint){
            optionWinHint.textContent =
              "Nur ohne Eliminierung: Entweder gewinnt die hÃ¶chste Gesamtpunktzahl oder die meisten gewonnenen Spiele (â˜…).";
          }
        }
      }

           function showScreen(name){
        Object.keys(screens).forEach(function(key){
          screens[key].classList.toggle("screen-active", key === name);
        });
        currentScreen = name;
        updateUnderwaterLoop();
      }


           let leaderToastTimeout = null;
      function showLeaderToast(name){
        if(!leaderToast || !leaderNameEl) return;
        leaderNameEl.textContent = name;
        leaderToast.classList.remove("hidden");
        leaderToast.classList.add("show");
        if(leaderToastTimeout){
          clearTimeout(leaderToastTimeout);
        }
        leaderToastTimeout = setTimeout(function(){
          leaderToast.classList.remove("show");
          leaderToastTimeout = setTimeout(function(){
            leaderToast.classList.add("hidden");
          }, 220);
        }, 3000); // vorher 1800 â€“ jetzt lÃ¤nger sichtbar
      }


      // Namen & Avatare sperren (nach erster Rundenwertung)
      function lockPlayerMeta(){
        playerRows.forEach(function(row){
          const nameInput   = row.querySelector(".player-name");
          const avatarBtn   = row.querySelector(".player-avatar");
          const avatarInput = row.querySelector(".player-avatar-input");
          if(nameInput)   nameInput.disabled = true;
          if(avatarBtn)   avatarBtn.disabled = true;
          if(avatarInput) avatarInput.disabled = true;
        });
      }

      // Soft-Reset: Punkte / Runden / Status, aber Namen & Avatare bleiben
      function resetGameState(){
        state.playerCount  = parseInt(playerCountSelect.value, 10) || 4;
        state.currentRound = 0;
        state.players      = [];
        state.currentLeaderId        = null;
        state.gameFinished           = false;
        state.pendingWinnerAfterMini = false;

        // Nur im Eliminierungsmodus Rundenlimit lÃ¶schen
        if(state.options.elimination){
          state.totalRounds = null;
        }

        // Highscores bleiben Ã¼ber mehrere Turniere bestehen

        playerCountSelect.disabled = false;

        const count = state.playerCount;
        playerRows.forEach(function(row, idx){
          row.dataset.id = String(idx);

          const nameInput   = row.querySelector(".player-name");
          const avatarBtn   = row.querySelector(".player-avatar");
          const avatarInput = row.querySelector(".player-avatar-input");
          const totalEl     = row.querySelector(".player-total");
          const roundInput  = row.querySelector(".input-round");
          const rankEl      = row.querySelector(".player-rank");
          const statusEl    = row.querySelector(".player-status");
          const winsEl      = row.querySelector(".player-wins");

          if(nameInput){
            nameInput.disabled = false;
          }
          if(avatarBtn){
            avatarBtn.disabled = false;
          }
          if(avatarInput){
            avatarInput.disabled = false;
          }

          if(totalEl)   totalEl.textContent = "0";
          if(roundInput){
            roundInput.value = "";
            roundInput.disabled = false;
            roundInput.classList.remove("input-error");
          }
          if(rankEl)    rankEl.textContent = "â€“";
          if(statusEl)  statusEl.textContent = "";
          if(winsEl)    winsEl.innerHTML = "";

          row.classList.remove("is-out", "is-inactive");

          if(idx < count){
            row.classList.remove("row-hidden");
          }else{
            row.classList.add("row-hidden");
          }
        });

        updateRoundInfo();
        updateHighscorePanel();
      }

      function getTrophyEmoji(index){
        if(index === 0) return "ðŸ¥‡";
        if(index === 1) return "ðŸ¥ˆ";
        if(index === 2) return "ðŸ¥‰";
        return "";
      }


      function updateFooterTip(){
        if(!footerTipEl) return;
        const tip = getRandomFishingTip();
        footerTipEl.textContent = "ðŸŽ£ Tipp: " + tip;
      }



      // Hard-Reset: inklusive Namen & Avatare (z.B. beim RÃ¼ckweg ins HauptmenÃ¼)
      function resetGameToDefaults(){
        // wieder auf 4 Spieler standardisieren
        playerCountSelect.value = "4";

        // Default-Avatare zufÃ¤llig verteilen (ohne Wiederholung)
        const perm = defaultAvatarImages.slice();
        shuffleArray(perm);

        playerRows.forEach(function(row, idx){
          const nameInput   = row.querySelector(".player-name");
          const avatarInner = row.querySelector(".player-avatar-inner");
          const avatarInput = row.querySelector(".player-avatar-input");
          const avatarBtn   = row.querySelector(".player-avatar");

          if(nameInput){
            nameInput.disabled   = false;
            nameInput.value      = "";
            nameInput.placeholder= "Spieler " + (idx + 1);
          }
          if(avatarInner){
            const img = perm[idx % perm.length];
            avatarInner.style.backgroundImage = "url('" + img + "')";
            avatarInner.textContent = "";
            avatarInner.classList.add("has-image");
          }
          if(avatarInput){
            avatarInput.value   = "";
            avatarInput.disabled= false;
          }
          if(avatarBtn){
            avatarBtn.disabled  = false;
          }
        });

        resetGameState();
      }

                function initPlayersFromUI(){
        state.players = [];
        const count = state.playerCount;
        for(let i = 0; i < count; i++){
          const row       = playerRows[i];
          const nameInput = row.querySelector(".player-name");
          const raw       = nameInput ? nameInput.value : "";
          const fallback  = "Spieler " + (i + 1);
          const name      = formatPlayerName(raw, fallback); // gibt "" zurÃ¼ck, wenn nichts eingegeben wurde

          if(nameInput){
            // bleibt leer â†’ Placeholder "Spieler X" wird angezeigt
            nameInput.value = name;
          }

          state.players.push({
            id: i,
            name: name,
            points: 0,
            wins: 0,
            isOut: false,
            initialIndex: i
          });
        }
      }




      function ensurePlayersInitialized(){
        if(state.players.length === 0){
          initPlayersFromUI();
        }
      }

      function getRowByPlayerId(id){
        for(let i = 0; i < playerRows.length; i++){
          const row = playerRows[i];
          if(parseInt(row.dataset.id || "-1", 10) === id){
            return row;
          }
        }
        return null;
      }

               function playerCompare(a, b){
        const aHasName = !!(a.name && a.name.trim());
        const bHasName = !!(b.name && b.name.trim());

        // Spieler ohne Namen immer ganz nach hinten
        if(aHasName && !bHasName) return -1;
        if(!aHasName && bHasName) return 1;

        // Ausgeschiedene Spieler nach hinten (aber vor komplett leeren, s.o.)
        if(a.isOut && !b.isOut) return 1;
        if(!a.isOut && b.isOut) return -1;

        const aw = a.wins || 0;
        const bw = b.wins || 0;

        if(!state.options.elimination && state.options.winCondition === "wins"){
          // Siegbedingung: Anzahl Siege
          if(bw !== aw) return bw - aw;
          if(b.points !== a.points) return b.points - a.points;
        }else{
          // Standard: nach Punkten, dann zur Not nach Siegen
          if(b.points !== a.points) return b.points - a.points;
          if(bw !== aw) return bw - aw;
        }

        return a.initialIndex - b.initialIndex;
      }



               function updateScoreboard(){
        if(!state.players.length) return;

        const sorted = state.players.slice().sort(playerCompare);
        const tbody  = playerTbody;

        sorted.forEach(function(p, index){
          const row = getRowByPlayerId(p.id);
          if(!row) return;
          tbody.appendChild(row);

          const nameInput  = row.querySelector(".player-name");
          const totalEl    = row.querySelector(".player-total");
          const roundInput = row.querySelector(".input-round");
          const rankEl     = row.querySelector(".player-rank");
          const statusEl   = row.querySelector(".player-status");
          const winsEl     = row.querySelector(".player-wins");

          if(nameInput) nameInput.value = p.name;
          if(totalEl)   totalEl.textContent = String(p.points);

          // Siege / Sterne aktualisieren
          if(winsEl){
            winsEl.innerHTML = "";
            const wins = p.wins || 0;
            for(let i = 0; i < wins; i++){
              const star = document.createElement("span");
              star.className = "player-win-star";
              star.textContent = "â˜…";
              winsEl.appendChild(star);
            }
          }

          const hasName = p.name && p.name.trim() !== "";

          if(!hasName){
            // Spieler ohne Namen: nimmt nicht teil
            row.classList.remove("is-out");
            row.classList.add("is-inactive");
            if(roundInput){
              roundInput.disabled = true;
              roundInput.value = "";
              roundInput.classList.remove("input-error");
            }
            if(rankEl)   rankEl.textContent = "â€“";
            if(statusEl) statusEl.textContent = "";
          }else if(p.isOut){
            // Ausgeschiedener Spieler
            row.classList.remove("is-inactive");
            row.classList.add("is-out");
            if(roundInput) roundInput.disabled = true;
            if(rankEl)     rankEl.textContent = "â€“";
            if(statusEl)   statusEl.textContent = "ausgeschieden";
          }else{
            // Aktiver Spieler im Rennen
            row.classList.remove("is-out", "is-inactive");
            if(roundInput) roundInput.disabled = false;
            if(rankEl)     rankEl.textContent = String(index + 1);
            if(statusEl)   statusEl.textContent = "";
          }
        });
      }



     function getActivePlayers(){
        return state.players.filter(function(p){
          return !p.isOut && p.name && p.name.trim() !== "";
        });
      }

            function getCurrentLeader(){
        const active = getActivePlayers();
        if(!active.length) return null;

        let sorted;
        if(state.options.elimination){
          // Im Eliminierungsmodus fÃ¼hren nach Punkten
          sorted = active.slice().sort(function(a, b){
            if(b.points !== a.points) return b.points - a.points;
            return a.initialIndex - b.initialIndex;
          });
        }else if(state.options.winCondition === "wins"){
          // Ohne Eliminierung: FÃ¼hrender nach Siegen
          sorted = active.slice().sort(function(a, b){
            const aw = a.wins || 0;
            const bw = b.wins || 0;
            if(bw !== aw) return bw - aw;
            if(b.points !== a.points) return b.points - a.points;
            return a.initialIndex - b.initialIndex;
          });
        }else{
          // Ohne Eliminierung: FÃ¼hrender nach Punkten
          sorted = active.slice().sort(function(a, b){
            if(b.points !== a.points) return b.points - a.points;
            const aw = a.wins || 0;
            const bw = b.wins || 0;
            if(bw !== aw) return bw - aw;
            return a.initialIndex - b.initialIndex;
          });
        }

        return sorted[0] || null;
      }


      function updateRoundInfo(){
        if(!roundInfo) return;
        if(state.options.elimination){
          const activeCount = getActivePlayers().length || state.playerCount;
          roundInfo.textContent = "Runde " + (state.currentRound) + " Â· Spieler im Rennen: " + activeCount;
        }else{
          const total = state.totalRounds || 0;
          roundInfo.textContent = "Runde " + (state.currentRound) + " von " + total;
        }
      }
      function updateHighscorePanel(){
        if(!hsBestRound || !hsBestGame) return;

        // Beste Runde
        if(state.highscores.bestRoundPoints > 0){
          hsBestRound.textContent =
            state.highscores.bestRoundPoints +
            " Punkte in einem Spiel: " +
            state.highscores.bestRoundName;
        }else{
          hsBestRound.textContent = "â€“ Punkte in einer Runde: â€“";
        }

        // Bestes Spiel
        if(state.highscores.bestGamePoints > 0 && state.highscores.bestGameRounds > 0){
          hsBestGame.textContent =
            state.highscores.bestGamePoints +
            " Punkte in einem Turnier Ã¼ber " +
            state.highscores.bestGameRounds +
            " Spiele: " +
            state.highscores.bestGameName;
        }else{
          hsBestGame.textContent = "â€“ Punkte in einem Turnier Ã¼ber â€“ Spiele: â€“";
        }
      }

                function validateRoundInputs(){
        ensurePlayersInitialized();
        const active = getActivePlayers();

        // Mindestens 2 Spieler mÃ¼ssen teilnehmen
        if(active.length < 2){
          playSound(sndFail);
          alert("Es mÃ¼ssen mindestens zwei Spieler mit Namen teilnehmen, bevor ihr ein Spiel werten kÃ¶nnt.");
          return false;
        }

        let allOk = true;

        // 1. Grundcheck: gÃ¼ltige Zahlen > 0
        active.forEach(function(p){
          const row = getRowByPlayerId(p.id);
          if(!row) return;

          const input = row.querySelector(".input-round");
          if(!input || input.disabled) return;

          const v = parseInt(input.value, 10);
          if(isNaN(v) || v <= 0){
            allOk = false;
            input.classList.add("input-error");
          }else{
            input.classList.remove("input-error");
          }
        });

        if(!allOk){
          const firstBad = active.find(function(p){
            const row = getRowByPlayerId(p.id);
            if(!row) return false;
            const input = row.querySelector(".input-round");
            if(!input || input.disabled) return false;
            const v = parseInt(input.value, 10);
            return isNaN(v) || v <= 0;
          });

          if(firstBad){
            const row = getRowByPlayerId(firstBad.id);
            if(row){
              const input = row.querySelector(".input-round");
              if(input){
                input.focus();
                if(input.select) input.select();
              }
            }
          }

          playSound(sndFail);
          return false;
        }

        // 2. Es MUSS einen eindeutigen Sieger geben
        const values = [];
        active.forEach(function(p){
          const row = getRowByPlayerId(p.id);
          if(!row) return;

          const input = row.querySelector(".input-round");
          if(!input || input.disabled) return;

          const v = parseInt(input.value, 10);
          if(!isNaN(v) && v > 0){
            values.push(v);
          }
        });

        if(!values.length){
          playSound(sndFail);
          return false;
        }

        const max = Math.max.apply(null, values);
        let countMax = 0;
        values.forEach(function(v){
          if(v === max) countMax++;
        });

        if(countMax !== 1){
          active.forEach(function(p){
            const row = getRowByPlayerId(p.id);
            if(!row) return;
            const input = row.querySelector(".input-round");
            if(!input || input.disabled) return;
            input.classList.add("input-error");
          });

          playSound(sndFail);
          alert("Es muss genau einen Sieger geben. Bitte die Punkte so anpassen, dass ein Spieler eindeutig die meisten Punkte hat.");
          return false;
        }

        return true;
      }




                 function applyRound(){
        if(state.gameFinished) return;

        if(!validateRoundInputs()){
          return;
        }

        ensurePlayersInitialized();

        const active = getActivePlayers();
        if(!active.length) return;

        const isFirstRound = (state.currentRound === 0);

        // Highscore fÃ¼r diese Runde tracken
        let bestThisRoundPoints = 0;
        let bestThisRoundName   = "";

        // Rundenscores pro Spieler merken (fÃ¼r die Sieg-Sterne)
        const roundDeltas = {};

        active.forEach(function(p){
          const row = getRowByPlayerId(p.id);
          if(!row) return;

          const roundInput = row.querySelector(".input-round");
          let delta = 0;

          if(roundInput){
            const v = parseInt(roundInput.value, 10);
            if(!isNaN(v) && v > 0) delta = v;

            roundInput.value = "";
            roundInput.classList.remove("input-error");
          }

          p.points += delta;
          roundDeltas[p.id] = delta;

          // Bester Rundenscore merken
          if(delta > bestThisRoundPoints){
            bestThisRoundPoints = delta;
            bestThisRoundName   = p.name;
          }
        });

        // Siege / Sterne: alle Spieler mit dem besten Rundenscore bekommen einen Stern
        if(bestThisRoundPoints > 0){
          active.forEach(function(p){
            if(roundDeltas[p.id] === bestThisRoundPoints){
              if(typeof p.wins !== "number"){
                p.wins = 0;
              }
              p.wins += 1;
            }
          });
        }

        // Globalen Runden-Highscore aktualisieren
        if(bestThisRoundPoints > state.highscores.bestRoundPoints){
          state.highscores.bestRoundPoints = bestThisRoundPoints;
          state.highscores.bestRoundName   = bestThisRoundName;
          saveHighscoresToStorage();
        }

        state.currentRound += 1;

        const previousLeaderId = state.currentLeaderId;
        updateScoreboard();
        const leader = getCurrentLeader();
        if(leader){
          state.currentLeaderId = leader.id;
          if(previousLeaderId === null || previousLeaderId !== leader.id){
            showLeaderToast(leader.name);
          }
        }

        // Ab jetzt: Namen & Avatare nicht mehr Ã¤nderbar
        if(isFirstRound){
          lockPlayerMeta();
        }

        playSound(sndPoints);

        if(state.options.elimination){
          handleEliminationAfterRound();
        }else{
          if(state.totalRounds && state.currentRound >= state.totalRounds){
            finishGame();
          }
        }

        updateRoundInfo();
        updateHighscorePanel();
        playerCountSelect.disabled = state.currentRound > 0;
      }



      function handleEliminationAfterRound(){
        const active = getActivePlayers();
        if(active.length <= 1){
          finishGame();
          return;
        }

        let minPoints = Infinity;
        active.forEach(function(p){
          if(p.points < minPoints) minPoints = p.points;
        });

        const candidates = active.filter(function(p){ return p.points === minPoints; });
        if(candidates.length === 1){
          const loser = candidates[0];
          loser.isOut = true;
          updateScoreboard();

          const remaining = getActivePlayers();
          state.pendingWinnerAfterMini = remaining.length === 1;

          showEliminationMiniGame(loser);
        }else{
          // Gleichstand: keine Eliminierung
        }
      }

      function showEliminationMiniGame(player){
        miniTitle.textContent = "Petri Heil â€“ Eliminierung";
        miniPlayerName.textContent = player.name;

        if(miniWater){
          miniWater.classList.remove("animate");
          void miniWater.offsetWidth;
        }
        if(miniPlayer){
          miniPlayer.classList.remove("fall", "show");
        }
        if(miniPlayerImg){
          miniPlayerImg.style.backgroundImage = "";
          miniPlayerImg.textContent = "ðŸŽ£";

          const row = getRowByPlayerId(player.id);
          if(row){
            const inner = row.querySelector(".player-avatar-inner");
            const avatarBtn = row.querySelector(".player-avatar");
            if(inner){
              const bg = inner.style.backgroundImage;
              if(bg && bg !== ""){
                miniPlayerImg.style.backgroundImage = bg;
                miniPlayerImg.textContent = "";
              }
            }
            if(avatarBtn && miniPlayer){
              const bc = avatarBtn.style.borderColor;
              if(bc){
                miniPlayer.style.borderColor = bc;
              }
            }
          }
        }

        showScreen("mini");

        if(btnMiniContinue){
          btnMiniContinue.disabled = true;
        }

        requestAnimationFrame(function(){
          requestAnimationFrame(function(){
            if(miniWater){
              miniWater.classList.add("animate");
            }
            if(miniPlayer){
              miniPlayer.classList.add("show");

              setTimeout(function(){
                miniPlayer.classList.add("fall");
                playSound(sndSplash);
              }, 1400);
            }else{
              playSound(sndSplash);
            }

            setTimeout(function(){
              if(btnMiniContinue){
                btnMiniContinue.disabled = false;
              }
            }, 2800);
          });
        });
      }

// Hilfsfunktion: Haben zwei Spieler denselben Rang (fÃ¼r Pokale)?
function haveSameRankForTrophy(a, b){
  if(!a || !b) return false;

  // Ausgeschiedene und aktive Spieler nie gleich ranken
  if(!!a.isOut !== !!b.isOut) return false;

  const aw = a.wins || 0;
  const bw = b.wins || 0;

  if(state.options.elimination){
    // Im Eliminierungsmodus: Punkte + Siege mÃ¼ssen gleich sein
    return a.points === b.points && aw === bw;
  }

  if(state.options.winCondition === "wins"){
    // Siegbedingung: nach Siegen, dann Punkte
    return aw === bw && a.points === b.points;
  }

  // Standard: nach Punkten, dann Siege
  return a.points === b.points && aw === bw;
}


                      function finishGame(){
        state.gameFinished = true;

        let allPlayers = [];
        let winners    = [];
        let headline   = "";

        // Nur Spieler mit eingetragenem Namen zÃ¤hlen
        const namedPlayers = state.players.filter(function(p){
          return p.name && p.name.trim() !== "";
        });

        if(!namedPlayers.length){
          return;
        }

        if(state.options.elimination){
          // Im Eliminierungsmodus gewinnt der/die letzte(n) verbleibende(n) Spieler
          allPlayers = namedPlayers.slice().sort(playerCompare);
          const active = allPlayers.filter(function(p){ return !p.isOut; });

          if(active.length === 0){
            // Fallback: hÃ¶chster Punktestand insgesamt unter allen benannten Spielern
            const maxPoints = Math.max.apply(null, namedPlayers.map(function(p){ return p.points; }));
            winners = namedPlayers.filter(function(p){ return p.points === maxPoints; });
          }else if(active.length === 1){
            winners = [active[0]];
          }else{
            const maxPoints = Math.max.apply(null, active.map(function(p){ return p.points; }));
            winners = active.filter(function(p){ return p.points === maxPoints; });
          }

          if(winners.length === 1){
            headline = winners[0].name + " hat das Turnier gewonnen!";
          }else{
            const names = winners.map(function(p){ return p.name; }).join(", ");
            headline = names + " haben gemeinsam das Turnier gewonnen!";
          }
        }else{
          // Kein Eliminierungsmodus: Siegbedingung beachten
          allPlayers = namedPlayers.slice();
          if(!allPlayers.length) return;

          if(state.options.winCondition === "wins"){
            // Sieger nach Anzahl gewonnener Spiele
            allPlayers.sort(function(a, b){
              const aw = a.wins || 0;
              const bw = b.wins || 0;
              if(bw !== aw) return bw - aw;
              if(b.points !== a.points) return b.points - a.points;
              return a.initialIndex - b.initialIndex;
            });

            const bestWins = allPlayers[0].wins || 0;
            winners = allPlayers.filter(function(p){ return (p.wins || 0) === bestWins; });

            if(winners.length === 1){
              headline =
                winners[0].name +
                " hat mit " +
                bestWins +
                " gewonnenen Spielen das Turnier gewonnen!";
            }else{
              const names = winners.map(function(p){ return p.name; }).join(", ");
              headline =
                names +
                " haben gemeinsam mit " +
                bestWins +
                " gewonnenen Spielen das Turnier gewonnen!";
            }
          }else{
            // Sieger nach Gesamtpunkten
            allPlayers.sort(function(a, b){
              if(b.points !== a.points) return b.points - a.points;
              const aw = a.wins || 0;
              const bw = b.wins || 0;
              if(bw !== aw) return bw - aw;
              return a.initialIndex - b.initialIndex;
            });

            const bestScore = allPlayers[0].points;
            winners = allPlayers.filter(function(p){ return p.points === bestScore; });

            if(winners.length === 1){
              headline =
                winners[0].name +
                " hat mit " +
                bestScore +
                " Punkten das Turnier gewonnen!";
            }else{
              const names = winners.map(function(p){ return p.name; }).join(", ");
              headline =
                names +
                " haben gemeinsam mit " +
                bestScore +
                " Punkten das Turnier gewonnen!";
            }
          }
        }

        // Ãœberschrift setzen
        winnerHeadline.textContent = headline;

        // Rangliste fÃ¼llen (mit Pokal + Avatar + Text)
        winnerRanking.innerHTML = "";
        if(allPlayers && allPlayers.length){

          // RÃ¤nge gruppieren: Spieler mit gleichem "Rankingzustand" bekommen denselben Rang
          const ranks = [];
          let currentRank = 1;

          for(let i = 0; i < allPlayers.length; i++){
            if(i === 0){
              ranks[i] = 1;
            }else{
              const prev = allPlayers[i - 1];
              const cur  = allPlayers[i];

              if(haveSameRankForTrophy(prev, cur)){
                // gleicher Rang wie der VorgÃ¤nger
                ranks[i] = currentRank;
              }else{
                // neuer Rang
                currentRank++;
                ranks[i] = currentRank;
              }
            }
          }

          allPlayers.forEach(function(p, index){
            const li = document.createElement("li");
            li.className = "ranking-item";

            const isWinner = winners.indexOf(p) !== -1;
            if(isWinner){
              li.classList.add("winner");
            }

            const rank = ranks[index] || (index + 1);

            // 1. Pokal links (SVG, per CSS eingefÃ¤rbt)
            const trophySpan = document.createElement("span");
            trophySpan.className = "rank-trophy";

            // Top-3 RÃ¤nge bekommen Pokale â€“ bei Gleichstand denselben Pokal
            if(rank === 1 || rank === 2 || rank === 3){
              const img = document.createElement("img");
              img.src = "assets/img/pokal.svg?v=1"; // Pfad ggf. anpassen
              img.alt = "Pokal";

              if(rank === 1){
                trophySpan.classList.add("trophy-gold");
              }else if(rank === 2){
                trophySpan.classList.add("trophy-silver");
              }else{
                trophySpan.classList.add("trophy-bronze");
              }

              trophySpan.appendChild(img);
            }else{
              // ab Rang 4 nur Platznummer
              trophySpan.textContent = rank + ".";
            }

            li.appendChild(trophySpan);

            // 2. Avatar (aus der Spielertabelle Ã¼bernehmen)
            const avatarWrapper = document.createElement("div");
            avatarWrapper.className = "rank-avatar";

            const avatarInner = document.createElement("div");
            avatarInner.className = "rank-avatar-inner";

            const row = getRowByPlayerId(p.id);
            if(row){
              const srcInner = row.querySelector(".player-avatar-inner");
              const srcBtn   = row.querySelector(".player-avatar");

              if(srcInner){
                const bg = srcInner.style.backgroundImage;
                if(bg && bg !== ""){
                  avatarInner.style.backgroundImage = bg;
                  avatarInner.textContent = "";
                }else{
                  avatarInner.textContent = srcInner.textContent || "ðŸŽ£";
                }
              }else{
                avatarInner.textContent = "ðŸŽ£";
              }

              // Rahmenfarbe vom Original Ã¼bernehmen
              if(srcBtn && srcBtn.style.borderColor){
                avatarWrapper.style.borderColor = srcBtn.style.borderColor;
              }
            }else{
              avatarInner.textContent = "ðŸŽ£";
            }

            avatarWrapper.appendChild(avatarInner);
            li.appendChild(avatarWrapper);

            // 3. Text (Name + Punkte + ggf. Siege)
            const textDiv = document.createElement("div");
            textDiv.className = "rank-text";

            const mainLine = document.createElement("div");
            mainLine.className = "rank-text-main";
            mainLine.textContent = p.name;

            const subLine = document.createElement("div");
            subLine.className = "rank-text-sub";

            let details = p.points + " Punkte";

            if(!state.options.elimination && state.options.winCondition === "wins"){
              details += " Â· " + (p.wins || 0) + " Siege";
            }else if((p.wins || 0) > 0){
              details += " Â· " + (p.wins || 0) + " Siegerunde(n)";
            }

            subLine.textContent = details;

            textDiv.appendChild(mainLine);
            textDiv.appendChild(subLine);
            li.appendChild(textDiv);

            winnerRanking.appendChild(li);
          });
        }

        // Highscore bestes Spiel (Punkte des Siegers â€“ erster Gewinner reicht)
        let championPoints = 0;
        if(winners && winners.length){
          championPoints = winners[0].points || 0;
        }

        if(championPoints > state.highscores.bestGamePoints){
          state.highscores.bestGamePoints = championPoints;
          state.highscores.bestGameRounds = state.currentRound;
          state.highscores.bestGameName   = winners.map(function(p){ return p.name; }).join(", ");
          saveHighscoresToStorage();
        }
        updateHighscorePanel();

        playSound(sndFanfare);
        showScreen("winner");
        updateFooterTip();
      }







      function startNewGameFromMain(){
        resetGameState();
        updateModeBadges();
        if(state.options.elimination){
          state.totalRounds = null;
          showScreen("game");
          ensurePlayersInitialized();
          updateScoreboard();
          updateRoundInfo();
        }else{
          showScreen("rounds");
        }
      }

      function confirmExitToMain(){
        exitModalBackdrop.classList.remove("hidden");
      }

      function cancelExitToMain(){
        exitModalBackdrop.classList.add("hidden");
      }

      function doExitToMain(){
        exitModalBackdrop.classList.add("hidden");
        resetGameToDefaults();
        showScreen("main");
      }

      // --- Event-Handler ---

           btnMainStart.addEventListener("click", function(){
        // zuerst versuchen, Vollbild + Querformat zu aktivieren
        tryEnterFullscreen();

        playSound(sndClick);
        startNewGameFromMain();
      });


      btnMainOptions.addEventListener("click", function(){
        playSound(sndClick);
        showScreen("options");
      });

      btnMainHelp.addEventListener("click", function(){
        playSound(sndClick);
        showScreen("help");
      });

            btnMainQuit.addEventListener("click", function(){
        playSound(sndClick);
        // Beim Beenden direkt zur Verlagsseite
        window.location.href = "https://www.schlachtenbummler-verlag.de";
        // Falls deine URL anders ist, hier einfach anpassen.
      });


             toggleElimination.addEventListener("click", function(){
        playSound(sndClick);
        state.options.elimination = !state.options.elimination;
        updateToggleVisual(toggleElimination, state.options.elimination);
        updateModeBadges();
        updateWinConditionUI();
        saveOptionsToStorage();
      });

           toggleSound.addEventListener("click", function(){
        state.options.sound = !state.options.sound;
        updateToggleVisual(toggleSound, state.options.sound);
        setRootSoundFlag();
        saveOptionsToStorage();
        updateUnderwaterLoop();   // Unterwasser-Loop mit umschalten
        playSound(sndClick);
      });


      if(btnWinCondition){
        btnWinCondition.addEventListener("click", function(){
          if(btnWinCondition.disabled) return;
          playSound(sndClick);
          state.options.winCondition =
            (state.options.winCondition === "points") ? "wins" : "points";
          updateWinConditionUI();
          saveOptionsToStorage();
        });
      }



      btnOptionsBack.addEventListener("click", function(){
        playSound(sndClick);
        showScreen("main");
      });

      btnRoundsBack.addEventListener("click", function(){
        playSound(sndClick);
        showScreen("main");
      });

      btnRoundsNext.addEventListener("click", function(){
        playSound(sndClick);
        const value = parseInt(roundCountInput.value, 10);
        if(isNaN(value) || value <= 0){
          roundCountInput.focus();
          return;
        }
        resetGameState();
        state.totalRounds = value;
        showScreen("game");
        ensurePlayersInitialized();
        updateScoreboard();
        updateRoundInfo();
      });

      playerCountSelect.addEventListener("change", function(){
        const val = parseInt(playerCountSelect.value, 10);
        if(state.currentRound > 0){
          playerCountSelect.value = String(state.playerCount);
          return;
        }
        if(!isNaN(val) && val >= 2 && val <= MAX_PLAYERS){
          state.playerCount = val;
          resetGameState();
          ensurePlayersInitialized();
          updateScoreboard();
        }
      });

                 // Namen-Ã„nderung + Verhalten beim Fokus:
      playerRows.forEach(function(row){
        var nameInput = row.querySelector(".player-name");
        if(!nameInput) return;

        // Beim Fokus: Standard "Spieler X" raus
        nameInput.addEventListener("focus", function(){
          var val         = nameInput.value.trim();
          var placeholder = nameInput.getAttribute("placeholder") || "";

          if(
            !val ||
            val === placeholder ||
            /^Spieler\s*\d*$/i.test(val)   // "Spieler", "Spieler 1", "Spieler 6" usw.
          ){
            nameInput.value = "";
          }
        });

        // Beim Ã„ndern: schÃ¶n formatieren und in state Ã¼bernehmen
        nameInput.addEventListener("change", function(){
          var id     = parseInt(row.dataset.id || "-1", 10);
          var player = state.players.find(function(p){ return p.id === id; });

          // Falls state.players noch leer ist (ganz am Anfang): nachinitialisieren
          if(!player){
            ensurePlayersInitialized();
            player = state.players.find(function(p){ return p.id === id; });
            if(!player) return;
          }

          var fallback  = "Spieler " + (player.initialIndex + 1);
          var formatted = formatPlayerName(nameInput.value, fallback);

          player.name     = formatted;
          nameInput.value = formatted;

          // sofort aktiv/inaktiv neu berechnen
          updateScoreboard();
        });
      });

      // Avatare (Kamera / Galerie)
      playerRows.forEach(function(row, idx){
        const avatarBtn = playerAvatarButtons[idx];
        const fileInput = playerAvatarInputs[idx];
        if(!avatarBtn || !fileInput) return;

        avatarBtn.addEventListener("click", function(){
          if(avatarBtn.disabled) return;
          playSound(sndClick);
          fileInput.click();
        });

        fileInput.addEventListener("change", function(){
          const file = fileInput.files && fileInput.files[0];
          if(!file) return;

          const reader = new FileReader();
          reader.onload = function(e){
            const dataUrl = e.target.result;
            const inner = row.querySelector(".player-avatar-inner");
            if(inner){
              inner.style.backgroundImage = "url('" + dataUrl + "')";
              inner.textContent = "";
              inner.classList.add("has-image");
            }
          };
          reader.readAsDataURL(file);
        });
      });


      btnRoundApply.addEventListener("click", function(){
        playSound(sndClick);
        applyRound();
      });

      btnRoundClear.addEventListener("click", function(){
        playSound(sndClick);
        playerRows.forEach(function(row){
          const input = row.querySelector(".input-round");
          if(input){
            input.value = "";
            input.classList.remove("input-error");
          }
        });
      });

      btnExitGame.addEventListener("click", function(){
        playSound(sndClick);
        confirmExitToMain();
      });

      btnExitCancel.addEventListener("click", function(){
        playSound(sndClick);
        cancelExitToMain();
      });

      btnExitConfirm.addEventListener("click", function(){
        playSound(sndClick);
        doExitToMain();
      });

      btnWinnerAgain.addEventListener("click", function(){
        playSound(sndClick);
        startNewGameFromMain(); // Namen & Avatare bleiben, werden aber wieder bearbeitbar
      });

      btnWinnerMenu.addEventListener("click", function(){
        playSound(sndClick);
        resetGameToDefaults();
        showScreen("main");
      });

      btnMiniContinue.addEventListener("click", function(){
        playSound(sndClick);
        if(state.pendingWinnerAfterMini){
          finishGame();
        }else{
          showScreen("game");
        }
      });

      btnHelpBack.addEventListener("click", function(){
        playSound(sndClick);
        showScreen("main");
      });

           // Zuerst versuchen, gespeicherte Optionen & Highscores zu laden
           loadFromStorage();

      updateToggleVisual(toggleElimination, state.options.elimination);
      updateToggleVisual(toggleSound, state.options.sound);
      setRootSoundFlag();
      updateModeBadges();
      updateWinConditionUI();

 // Initial den Unterwasser-Loop passend setzen
      updateUnderwaterLoop();

      // Initial: alles auf Defaults (inkl. zufÃ¤llige Avatare) zurÃ¼cksetzen
      resetGameToDefaults();
      ensurePlayersInitialized();
      updateScoreboard();
      updateRoundInfo();
      updateHighscorePanel();
      // Unterwasser-Blasen nur im HauptmenÃ¼ initialisieren
      initBubbleLayer();
      
// Vollbild / Querformat beim ersten Nutzer-Eingriff vorbereiten
      setupFullscreenOnFirstInteraction();


           // ----------------------------------------
      // Unterwasser-Blasen im HauptmenÃ¼
      // ----------------------------------------

      function randomizeBubble(el){
        if(!el) return;

        // 20â€“25% Chance auf groÃŸe Blasen
        let size;
        if(Math.random() < 0.25){
          size = 30 + Math.random() * 26;   // 30â€“56px
        }else{
          size = 8 + Math.random() * 22;    // 8â€“30px
        }

        // irgendwo Ã¼ber die ganze Breite
        const left = Math.random() * 100;

        // unterschiedlich schnelle Blasen
        const duration = 10 + Math.random() * 20; // 10â€“30s
        const delay    = -Math.random() * duration;
        const drift    = (Math.random() * 40 - 20) + "px"; // leichtes seitliches Driften

        el.style.setProperty("--bubble-size",     size + "px");
        el.style.setProperty("--bubble-left",     left + "%");
        el.style.setProperty("--bubble-duration", duration + "s");
        el.style.setProperty("--bubble-delay",    delay + "s");
        el.style.setProperty("--bubble-drift",    drift);
      }

      function popBubble(el){
        if(!el) return;

        // Sound abspielen
        playBubblePopSound();

        // aktuelle Transform-Matrix als Basis fÃ¼r die Pop-Animation speichern
        const cs = window.getComputedStyle(el);
        const t  = cs.transform === "none" ? "translate3d(0,0,0)" : cs.transform;
        el.style.setProperty("--bubble-pop-base-transform", t);

        el.classList.add("bubble-pop");

        el.addEventListener("animationend", function handler(){
          el.removeEventListener("animationend", handler);
          el.classList.remove("bubble-pop");
          el.style.removeProperty("--bubble-pop-base-transform");

          // Neue Zufallswerte & wieder normal aufsteigen lassen
          randomizeBubble(el);
        });
      }

      function initBubbleLayer(){
        const layer = document.getElementById("bubble-layer");
        if(!layer) return;

        // Beim (Neu-)Aufruf erst mal alles leeren
        layer.innerHTML = "";

        const bubbleCount = 22; // Anzahl Blasen im HauptmenÃ¼
        for(let i = 0; i < bubbleCount; i++){
          const el = document.createElement("div");
          el.className = "bubble";

          randomizeBubble(el);

          el.addEventListener("click", function(ev){
            ev.stopPropagation();
            popBubble(el);
          });

          layer.appendChild(el);
        }
      }



    })();

  </script>


</body>
</html>
